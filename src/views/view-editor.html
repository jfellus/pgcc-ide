
<dom-module id="view-editor">
<style>
	svg {
		width:100%; height:100%; box-sizing: border-box;
	}

	svg /deep/ rect.module {
		z-index:10;
		stroke-width:1;
		stroke:#666666;
		fill:#DDDDDD;
	}

	svg /deep/ text.module {
		font-size:11px;
	}

	svg /deep/ rect.pin {
		stroke:none;
		fill:black;
	}
	svg /deep/ text.pin {
		font-size:10px;
	}

	svg /deep/ path {
		stroke-width:1;
		stroke:black;
		z-index:-11;
		fill:none;
	}

	svg /deep/ .selected rect.module,
	svg /deep/ path.selected {
		stroke-width:3;
		stroke:red;
	}

	#loading { position:absolute; top:0; left:0; bottom:0; right:0; background:#dddddd; color:#777777; font-size:20px; font-weight:bold; display:flex; justify-content: center; align-items: center; }

</style>
<template>
	<div id="loading">Loading ...</div>
	<svg id="svg">
		<g id="world"></g>
	</svg>
</template>
</dom-module>
<script>

var PGCC = require("pgcc");

function Module(name) {
	this.x = Math.random()*1000;
	this.y = Math.random()*700,
	this.name = name;

	this.pins = [
			{ name:"VCC", side:"left" },
			{ name:"Vin", side:"left"},
			{ name:"OV", side:"left"},
			{ name:"learn", side:"top"},
			{ name:"RX", side:'right'},
			{ name:"TX", side:"right"}
		];

	this.moveListeners = [];
}


function Link(src, dst, srcPin, dstPin) {
	this.src = src;
	this.dst = dst;
	this.srcPin = srcPin;
	this.dstPin = dstPin;
};




var LAST_NEW_DOC = 0;


Polymer({
	is: 'view-editor',
	properties: {
		selection: {notify:true, value:null},
		modified: {notify:true, observer:"onModifiedChanged"},
		filename: {notify:true}
	},
	observers: {
		'loaded': 'onLoaded'
	},

	attached: function() {
		var that = this;
		var _zooming = false;

		this.modules = [];

		// Setup mouse navigation
		this.zoomBehavior = d3.behavior.zoom().scaleExtent([0.04,200])
		.on('zoomstart', function(){})
		.on('zoom', function (){
			d3.select(that.$.world).attr('transform', 'translate(' + d3.event.translate + '),scale(' + d3.event.scale + ')');
		})
		.on('zoomend', function(){});
		d3.select(this.$.svg).call(this.zoomBehavior);

		// Pan view only with middle mouse button
		var fn_mousemove = d3.select(this.$.svg).on("mousedown.zoom");
		d3.select(this.$.svg).on("mousedown.zoom", function(){
			if(d3.event.which === 2) return fn_mousemove.apply(this, arguments);
		});

		this.$.svg.addEventListener("click", function() {that.unselect();});

		this.world = d3.select(this.$.world);


		if(this.filename) this.async(function() {this.open(this.filename); });
		else this.async(function() {this.newDocument();})
	},

	newDocument: function() {
		this.filename = "NewScript_"+(LAST_NEW_DOC++)+".script";
		this.fire("label", this.filename);
		this.script = new PGCC.Script();
		this.onLoaded();
		this.modified = true;
	},

	open: function(filename) {
		var that = this;
		this.filename = filename;
		this.script = new PGCC.Script(filename);
		if(!this.script) throw "Script can't be loaded " + filename;

		this.script.on("loaded", function() {
			that.script.modules.forEach(function(m) { that.addModule(m); });
			that.script.links.forEach(function(l) {	that.addLink(l); });
			setTimeout(function() {that.onLoaded();},10);
		});

	},

	close: function() {
		var that = this;
		if(!this.modified) return this.fire("close");
		if(confirm(this.filename + " has been modified. Save changes ?")) {
			this.save();
			setTimeout(function(){that.fire("close");}, 40);
		}
	},

	save: function() { return this.saveAs(this.filename); },

	saveAs: function(filename) {
		var that = this;
		ZOB = this.script;
		return this.script.write(filename).then(function() {
			that.filename = filename;
			that.fire("label", this.filename);
			that.modified = false;
		}).catch(function(e) { alert(e);});
	},


	onLoaded: function() {
		this.modified = false;
		$(this.$.loading).fadeOut();
	},

	onFocus: function() {
		WORKBENCH.curEditor = this;
	},

	getModule: function(name) {
		var m = this.modules.filter(function(m){return m.name === name; });
		return m.length ? m[0] : null;
	},

	addModule: function(m) {
		var that = this;
		if(!m.x) m.x = m.params.x;
		if(!m.y) m.y = m.params.y;
		if(!m.x) m.params.x = m.x = Math.random()*1000;
		if(!m.y) m.params.y = m.y = Math.random()*700;

		var module = this.world.append("g")
			.attr("transform" , "translate(" + m.x+ "," +m.y + ")");

		m.component = module;
		m.pinCoords = {};

		var w = 85;
		var h = 65;

		module.moveListeners = [];
		module.onMove = function(callback) {
			this.moveListeners.push(callback);
		};


		var dragBehavior = d3.behavior.drag()
	      .on("drag", function() {
			  	if(d3.event.sourceEvent.which !== 1) return;

				that.select(m);

			  	var tr = d3.transform(d3.select(this).attr("transform"));
				tr.translate[0] += d3.event.dx;
	            tr.translate[1] += d3.event.dy;
				m.params.x = m.x = tr.translate[0];
				m.params.y = m.y = tr.translate[1];

				for(var i in m.pinCoords) {
					m.pinCoords[i].x += d3.event.dx;
					m.pinCoords[i].y += d3.event.dy;
				}

	            d3.select(this).attr("transform", "translate("+tr.translate+")");
				module.moveListeners.forEach(function(cb) { cb.bind(m)(); });
				that.modified = true;
	      });
		module.call(dragBehavior);

		module.append("rect")
			.classed("module", true)
			.attr("x", -w/2)
			.attr("y", -h/2)
    		.attr("rx", 3)
    		.attr("ry", 3)
    		.attr("width", w)
    		.attr("height", h);

		module.append("text")
			.classed("module", true)
			.text(m.class + " " + m.id)
			.attr('text-anchor',"middle")
			.attr('y', h/2+2)
			.attr("dominant-baseline", "text-before-edge");

		function addPin(name, side, pct) {
			var x,y;
			var MARG = 1;
			if(side=="left") { x = -w/2; y = (pct-0.5)*MARG*h; }
			else if(side=="right") { x = w/2; y = (pct-0.5)*MARG*h; }
			else if(side=="top") { x = (pct-0.5)*MARG*w; y = -h/2; }
			else if(side=="bottom") { x = (pct-0.5)*MARG*w; y = h/2; }
			else return;
			var pin = module.append("rect")
				.classed("pin", true)
				.attr("x", x-5/2)
				.attr("y", y-5/2)
				.attr("rx", 1)
				.attr("ry", 1)
				.attr("width", 5)
				.attr("height", 5);
			module.append("text")
				.classed("pin", true)
				.attr("x", side==="top" || side==="bottom" ? x : side==="left" ? x + 3 : x - 3)
				.attr("y", side==="left" || side==="right" ? y : side==="top" ? y + 3 : y - 3)
				.attr("dominant-baseline", side==="left" || side==="right" ? "central" : side==="top" ?  "text-before-edge" : "text-after-edge" )
				.attr("text-anchor", side==="top" || side==="bottom" ? "middle" : side==="left" ? "start" : "end")
				.text(name);

			var ctm = pin.node().getCTM();
			m.pinCoords[name] = {x:ctm.e+x,y:ctm.f+y};
		}

		if(m.pins) {
			["left", "right", "top", "bottom"].forEach(function(side){
				var pins = m.pins.filter(function(p){return p.side === side; });
				for(var i=0; i<pins.length; i++) {
					addPin(pins[i].name, side, (i+1)/(pins.length+1));
				}
			});
		}

		module.node().addEventListener("click", function(e) { that.select(m); e.stopPropagation(); });

		this.push("modules", m);
	},

	addLink: function(link) {

		function getSrcPoint() {
			var ptSrc = link.src;
			if(link.srcPin && ptSrc.pinCoords[link.srcPin]) ptSrc = ptSrc.pinCoords[link.srcPin];
			return [ptSrc.x, ptSrc.y];
		}

		function getDstPoint() {
			var ptDst = link.dst;
			if(link.dstPin && ptDst.pinCoords[link.dstPin]) ptDst = ptDst.pinCoords[link.dstPin];
			return [ptDst.x, ptDst.y];
		}

		function bezier() {
			//	return "M"+[x1,y1]+" C"+[x2,y1,x1,y2,x2,y2];
			return "M"+getSrcPoint()+ "L"+getDstPoint();
		}

		var line = this.world.insert("path", "g").attr("d", bezier());

		link.component = line;

		line.node().addEventListener("click", function(e) {
			that.select(link); e.stopPropagation();
		});

		link.src.component.onMove(function(){ line.attr("d", bezier()); });
		link.dst.component.onMove(function(){ line.attr("d", bezier()); });
	},


	connect: function(src, dst, srcPin, dstPin) {
		var that = this;
		if(typeof(src) === 'string' && src.indexOf(".")!==-1) { srcPin = src.split(".")[1]; src = src.split(".")[0];  }
		if(typeof(dst) === 'string' && dst.indexOf(".")!==-1) { dstPin = dst.split(".")[1]; dst = dst.split(".")[0];  }
		if(typeof(src) === 'string') src = this.getModule(src);
		if(typeof(dst) === 'string') dst = this.getModule(dst);
		if(!src || !dst) throw "No such modules (" + src + " -> " + dst + ")";

		var link = new Link(src, dst, srcPin, dstPin);
		this.addLink(link);
		this.modified = true;
	},



	select: function(o) {
		if(this.selection) {
			var s = this.selection.component;
			if(!s) s = this.selection;
			s.classed("selected", false);
		}
		this.selection = o;
		var s = this.selection.component;
		if(!s) s = this.selection;
		s.classed("selected", true);
	},

	unselect: function() {
		if(this.selection) {
			var s = this.selection.component;
			if(!s) s = this.selection;
			s.classed("selected", false);
		}
		this.selection = null;
	},


	onModifiedChanged: function() {
		if(this.modified) this.fire("label", this.filename + "*");
		else this.fire("label", this.filename);
	}

});


</script>
