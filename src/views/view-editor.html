<script>
const EventEmitter = require('events').EventEmitter;
const util = require('util');
</script>
<link rel="import" href="../components/ModuleComponent.html">
<link rel="import" href="../components/LinkComponent.html">
<link rel="import" href="../components/ModuleCreator.html">


<dom-module id="view-editor">
<style>
	svg {
		width:100%; height:100%; box-sizing: border-box;
	}

	svg /deep/ rect.module {
		z-index:10;
		stroke-width:1;
		stroke:#666666;
		fill:#DDDDDD;
	}

	svg /deep/ text.module {
		font-size:11px;
	}

	svg /deep/ rect.pin {
		stroke:none;
		fill:black;
	}
	svg /deep/ text.pin {
		font-size:10px;
	}

	svg /deep/ path {
		stroke-width:1;
		stroke:black;
		z-index:-11;
		fill:none;
	}

	svg /deep/ .selected rect.module,
	svg /deep/ path.selected {
		stroke-width:3;
		stroke:red;
	}

	#loading { position:absolute; top:0; left:0; bottom:0; right:0; background:#dddddd; color:#777777; font-size:20px; font-weight:bold; display:flex; justify-content: center; align-items: center; }

</style>
<template>
	<div id="loading">Loading ...</div>
	<svg id="svg">
		<g id="world"></g>
	</svg>
</template>
</dom-module>
<script>


var PGCC = require("pgcc");

var LAST_NEW_DOC = 0;


Polymer({
	is: 'view-editor',
	properties: {
		selection: {notify:true, value:null},
		modified: {notify:true, observer:"onModifiedChanged"},
		filename: {notify:true}
	},
	observers: {
		'loaded': 'onLoaded'
	},

	attached: function() {
		var that = this;
		var _zooming = false;

		this.modules = [];

		// Setup mouse navigation
		this.zoomBehavior = d3.behavior.zoom().scaleExtent([0.04,200])
		.on('zoomstart', function(){})
		.on('zoom', function (){
			d3.select(that.$.world).attr('transform', 'translate(' + d3.event.translate + '),scale(' + d3.event.scale + ')');
		})
		.on('zoomend', function(){});
		d3.select(this.$.svg).call(this.zoomBehavior);

		// Pan view only with middle mouse button
		var fn_mousemove = d3.select(this.$.svg).on("mousedown.zoom");
		d3.select(this.$.svg).on("mousedown.zoom", function(){
			if(d3.event.which === 2) return fn_mousemove.apply(this, arguments);
		});

		this.$.svg.addEventListener("click", function() {that.unselect();});

		this.world = d3.select(this.$.world);


		if(this.filename) this.async(function() {this.open(this.filename); });
		else this.async(function() {this.newDocument();})
	},

	newDocument: function() {
		this.filename = "NewScript_"+(LAST_NEW_DOC++)+".script";
		this.fire("label", this.filename);
		this.script = new PGCC.Script();
		this.onLoaded();
		this.modified = true;
	},

	open: function(filename) {
		var that = this;
		this.filename = filename;
		this.script = new PGCC.Script(filename);
		if(!this.script) throw "Script can't be loaded " + filename;

		this.script.on("loaded", function() {
			that.script.modules.forEach(function(m) { that.addModule(m); });
			that.script.links.forEach(function(l) {	that.addLink(l); });
			setTimeout(function() {that.onLoaded();},10);
		});

	},

	close: function() {
		var that = this;
		if(!this.modified) return this.fire("close");
		if(confirm(this.filename + " has been modified. Save changes ?")) {
			this.save();
			setTimeout(function(){that.fire("close");}, 40);
		}
	},

	save: function() { return this.saveAs(this.filename); },

	saveAs: function(filename) {
		var that = this;
		ZOB = this.script;
		return this.script.write(filename).then(function() {
			that.filename = filename;
			that.fire("label", this.filename);
			that.modified = false;
		}).catch(function(e) { alert(e);});
	},


	onLoaded: function() {
		this.modified = false;
		$(this.$.loading).fadeOut();
	},

	onFocus: function() {
		WORKBENCH.curEditor = this;
	},

	getModule: function(name) {
		var m = this.modules.filter(function(m){return m.name === name; });
		return m.length ? m[0] : null;
	},

	addModule: function(m) {
		m.component = new ModuleComponent(this, m);
		this.push("modules", m);
	},

	addLink: function(l) {
		l.component = new LinkComponent(this, l);
	},


	connect: function(src, dst, srcPin, dstPin) {
		var that = this;
		if(typeof(src) === 'string' && src.indexOf(".")!==-1) { srcPin = src.split(".")[1]; src = src.split(".")[0];  }
		if(typeof(dst) === 'string' && dst.indexOf(".")!==-1) { dstPin = dst.split(".")[1]; dst = dst.split(".")[0];  }
		if(typeof(src) === 'string') src = this.getModule(src);
		if(typeof(dst) === 'string') dst = this.getModule(dst);
		if(!src || !dst) throw "No such modules (" + src + " -> " + dst + ")";

		var link = new Link(src, dst, srcPin, dstPin);
		this.addLink(link);
		this.modified = true;
		WORKBENCH.fire("modify");
	},

	getSelection: function() {
		var s = this.selection.component;
		if(!s) return this.selection;
		return s;
	},

	select: function(o) {
		if(this.selection) this.getSelection().setSelected(false);
		this.selection = o;
		this.getSelection().setSelected(true);

		WORKBENCH.selection = this.selection;
	},

	unselect: function() {
		if(this.selection) this.getSelection().setSelected(false);
		this.selection = null;

		WORKBENCH.selection = this.selection;
	},


	onModifiedChanged: function() {
		if(this.modified) this.fire("label", this.filename + "*");
		else this.fire("label", this.filename || "null");
	},


	createModule: function(hint) {
		if(!this.script) return;
		if(this.creator) this.creator.cancel();

		var m = new PGCC.Module(this.script);
		m.class = hint.class;
		m.id = hint.class + "0";
		if(hint.id) m.id = hint.id;

		this.creator = new ModuleCreator(this, m);
		this.creator.on("create", function() {that.push("modules", m);});
	},

	clientToWorld: function(pt) {
		var tr = d3.transform(this.world.attr("transform"));
		var x = (pt.x - tr.translate[0]) / tr.scale[0];
		var y = (pt.y - tr.translate[1]) / tr.scale[1] ;
		return {x:x,y:y};
	}

});


</script>
